{-
   CVPartner

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.1
   CVPartner API version: 0.0.1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : CVPartner.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module CVPartner.Model where

import CVPartner.Core
import CVPartner.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** CvId
newtype CvId = CvId { unCvId :: Text } deriving (P.Eq, P.Show)

-- ** Deactivated
newtype Deactivated = Deactivated { unDeactivated :: Bool } deriving (P.Eq, P.Show)

-- ** From
newtype From = From { unFrom :: Int } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** OfficeIds
newtype OfficeIds = OfficeIds { unOfficeIds :: [Text] } deriving (P.Eq, P.Show)

-- ** Role
newtype Role = Role { unRole :: Text } deriving (P.Eq, P.Show)

-- ** SectionId
newtype SectionId = SectionId { unSectionId :: Text } deriving (P.Eq, P.Show)

-- ** SectionType
newtype SectionType = SectionType { unSectionType :: Text } deriving (P.Eq, P.Show)

-- ** Size
newtype Size = Size { unSize :: Int } deriving (P.Eq, P.Show)

-- ** SortBy
newtype SortBy = SortBy { unSortBy :: Text } deriving (P.Eq, P.Show)

-- ** UserId
newtype UserId = UserId { unUserId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Certification
-- | Certification
data Certification = Certification
  { certificationOrder :: !(Maybe Int) -- ^ "order"
  , certificationStarred :: !(Maybe Bool) -- ^ "starred"
  , certificationDisabled :: !(Maybe Bool) -- ^ "disabled"
  , certificationVersion :: !(Maybe Int) -- ^ "version"
  , certificationExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , certificationOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , certificationCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , certificationUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , certificationName :: !(Maybe A.Value) -- ^ "name"
  , certificationLongDescription :: !(Maybe A.Value) -- ^ "long_description"
  , certificationOrganizer :: !(Maybe A.Value) -- ^ "organizer"
  , certificationYear :: !(Maybe Text) -- ^ "year"
  , certificationMonth :: !(Maybe Text) -- ^ "month"
  , certificationYearExpire :: !(Maybe Text) -- ^ "year_expire"
  , certificationMonthExpire :: !(Maybe Text) -- ^ "month_expire"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Certification
instance A.FromJSON Certification where
  parseJSON = A.withObject "Certification" $ \o ->
    Certification
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "name")
      <*> (o .:? "long_description")
      <*> (o .:? "organizer")
      <*> (o .:? "year")
      <*> (o .:? "month")
      <*> (o .:? "year_expire")
      <*> (o .:? "month_expire")

-- | ToJSON Certification
instance A.ToJSON Certification where
  toJSON Certification {..} =
   _omitNulls
      [ "order" .= certificationOrder
      , "starred" .= certificationStarred
      , "disabled" .= certificationDisabled
      , "version" .= certificationVersion
      , "external_unique_id" .= certificationExternalUniqueId
      , "owner_updated_at" .= certificationOwnerUpdatedAt
      , "created_at" .= certificationCreatedAt
      , "updated_at" .= certificationUpdatedAt
      , "name" .= certificationName
      , "long_description" .= certificationLongDescription
      , "organizer" .= certificationOrganizer
      , "year" .= certificationYear
      , "month" .= certificationMonth
      , "year_expire" .= certificationYearExpire
      , "month_expire" .= certificationMonthExpire
      ]


-- | Construct a value of type 'Certification' (by applying it's required fields, if any)
mkCertification
  :: Certification
mkCertification =
  Certification
  { certificationOrder = Nothing
  , certificationStarred = Nothing
  , certificationDisabled = Nothing
  , certificationVersion = Nothing
  , certificationExternalUniqueId = Nothing
  , certificationOwnerUpdatedAt = Nothing
  , certificationCreatedAt = Nothing
  , certificationUpdatedAt = Nothing
  , certificationName = Nothing
  , certificationLongDescription = Nothing
  , certificationOrganizer = Nothing
  , certificationYear = Nothing
  , certificationMonth = Nothing
  , certificationYearExpire = Nothing
  , certificationMonthExpire = Nothing
  }

-- ** Country
-- | Country
data Country = Country
  { countryId :: !(Text) -- ^ /Required/ "_id"
  , countryCode :: !(Text) -- ^ /Required/ "code"
  , countryOffices :: !([Office]) -- ^ /Required/ "offices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Country
instance A.FromJSON Country where
  parseJSON = A.withObject "Country" $ \o ->
    Country
      <$> (o .:  "_id")
      <*> (o .:  "code")
      <*> (o .:  "offices")

-- | ToJSON Country
instance A.ToJSON Country where
  toJSON Country {..} =
   _omitNulls
      [ "_id" .= countryId
      , "code" .= countryCode
      , "offices" .= countryOffices
      ]


-- | Construct a value of type 'Country' (by applying it's required fields, if any)
mkCountry
  :: Text -- ^ 'countryId' 
  -> Text -- ^ 'countryCode' 
  -> [Office] -- ^ 'countryOffices' 
  -> Country
mkCountry countryId countryCode countryOffices =
  Country
  { countryId
  , countryCode
  , countryOffices
  }

-- ** Course
-- | Course
data Course = Course
  { courseOrder :: !(Maybe Int) -- ^ "order"
  , courseStarred :: !(Maybe Bool) -- ^ "starred"
  , courseDisabled :: !(Maybe Bool) -- ^ "disabled"
  , courseVersion :: !(Maybe Int) -- ^ "version"
  , courseExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , courseOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , courseCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , courseUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , courseName :: !(Maybe A.Value) -- ^ "name"
  , courseLongDescription :: !(Maybe A.Value) -- ^ "long_description"
  , courseProgram :: !(Maybe A.Value) -- ^ "program"
  , courseYear :: !(Maybe Text) -- ^ "year"
  , courseMonth :: !(Maybe Text) -- ^ "month"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Course
instance A.FromJSON Course where
  parseJSON = A.withObject "Course" $ \o ->
    Course
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "name")
      <*> (o .:? "long_description")
      <*> (o .:? "program")
      <*> (o .:? "year")
      <*> (o .:? "month")

-- | ToJSON Course
instance A.ToJSON Course where
  toJSON Course {..} =
   _omitNulls
      [ "order" .= courseOrder
      , "starred" .= courseStarred
      , "disabled" .= courseDisabled
      , "version" .= courseVersion
      , "external_unique_id" .= courseExternalUniqueId
      , "owner_updated_at" .= courseOwnerUpdatedAt
      , "created_at" .= courseCreatedAt
      , "updated_at" .= courseUpdatedAt
      , "name" .= courseName
      , "long_description" .= courseLongDescription
      , "program" .= courseProgram
      , "year" .= courseYear
      , "month" .= courseMonth
      ]


-- | Construct a value of type 'Course' (by applying it's required fields, if any)
mkCourse
  :: Course
mkCourse =
  Course
  { courseOrder = Nothing
  , courseStarred = Nothing
  , courseDisabled = Nothing
  , courseVersion = Nothing
  , courseExternalUniqueId = Nothing
  , courseOwnerUpdatedAt = Nothing
  , courseCreatedAt = Nothing
  , courseUpdatedAt = Nothing
  , courseName = Nothing
  , courseLongDescription = Nothing
  , courseProgram = Nothing
  , courseYear = Nothing
  , courseMonth = Nothing
  }

-- ** Cv
-- | Cv
data Cv = Cv
  { cvId :: !(Maybe Text) -- ^ "id"
  , cvUserId :: !(Maybe Text) -- ^ "user_id"
  , cvCompanyId :: !(Maybe Text) -- ^ "company_id"
  , cvName :: !(Maybe Text) -- ^ "name"
  , cvTitle :: !(Maybe A.Value) -- ^ "title"
  , cvEmail :: !(Maybe Text) -- ^ "email"
  , cvBornDay :: !(Maybe Int) -- ^ "born_day"
  , cvBornMonth :: !(Maybe Int) -- ^ "born_month"
  , cvBornYear :: !(Maybe Int) -- ^ "born_year"
  , cvNationality :: !(Maybe A.Value) -- ^ "nationality"
  , cvPlaceOfResidence :: !(Maybe A.Value) -- ^ "place_of_residence"
  , cvEducations :: !(Maybe [Education]) -- ^ "educations"
  , cvKeyQualifications :: !(Maybe [KeyQualification]) -- ^ "key_qualifications"
  , cvProjectExperiences :: !(Maybe [ProjectExperience]) -- ^ "project_experiences"
  , cvWorkExperiences :: !(Maybe [WorkExperience]) -- ^ "work_experiences"
  , cvLanguages :: !(Maybe [Language]) -- ^ "languages"
  , cvTechnologies :: !(Maybe [Technology]) -- ^ "technologies"
  , cvCertifications :: !(Maybe [Certification]) -- ^ "certifications"
  , cvCourses :: !(Maybe [Course]) -- ^ "courses"
  , cvPresentations :: !(Maybe [Presentation]) -- ^ "presentations"
  , cvRecommendations :: !(Maybe [Recommendation]) -- ^ "recommendations"
  , cvPositions :: !(Maybe [Position]) -- ^ "positions"
  , cvImage :: !(Maybe UserImage) -- ^ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Cv
instance A.FromJSON Cv where
  parseJSON = A.withObject "Cv" $ \o ->
    Cv
      <$> (o .:? "id")
      <*> (o .:? "user_id")
      <*> (o .:? "company_id")
      <*> (o .:? "name")
      <*> (o .:? "title")
      <*> (o .:? "email")
      <*> (o .:? "born_day")
      <*> (o .:? "born_month")
      <*> (o .:? "born_year")
      <*> (o .:? "nationality")
      <*> (o .:? "place_of_residence")
      <*> (o .:? "educations")
      <*> (o .:? "key_qualifications")
      <*> (o .:? "project_experiences")
      <*> (o .:? "work_experiences")
      <*> (o .:? "languages")
      <*> (o .:? "technologies")
      <*> (o .:? "certifications")
      <*> (o .:? "courses")
      <*> (o .:? "presentations")
      <*> (o .:? "recommendations")
      <*> (o .:? "positions")
      <*> (o .:? "image")

-- | ToJSON Cv
instance A.ToJSON Cv where
  toJSON Cv {..} =
   _omitNulls
      [ "id" .= cvId
      , "user_id" .= cvUserId
      , "company_id" .= cvCompanyId
      , "name" .= cvName
      , "title" .= cvTitle
      , "email" .= cvEmail
      , "born_day" .= cvBornDay
      , "born_month" .= cvBornMonth
      , "born_year" .= cvBornYear
      , "nationality" .= cvNationality
      , "place_of_residence" .= cvPlaceOfResidence
      , "educations" .= cvEducations
      , "key_qualifications" .= cvKeyQualifications
      , "project_experiences" .= cvProjectExperiences
      , "work_experiences" .= cvWorkExperiences
      , "languages" .= cvLanguages
      , "technologies" .= cvTechnologies
      , "certifications" .= cvCertifications
      , "courses" .= cvCourses
      , "presentations" .= cvPresentations
      , "recommendations" .= cvRecommendations
      , "positions" .= cvPositions
      , "image" .= cvImage
      ]


-- | Construct a value of type 'Cv' (by applying it's required fields, if any)
mkCv
  :: Cv
mkCv =
  Cv
  { cvId = Nothing
  , cvUserId = Nothing
  , cvCompanyId = Nothing
  , cvName = Nothing
  , cvTitle = Nothing
  , cvEmail = Nothing
  , cvBornDay = Nothing
  , cvBornMonth = Nothing
  , cvBornYear = Nothing
  , cvNationality = Nothing
  , cvPlaceOfResidence = Nothing
  , cvEducations = Nothing
  , cvKeyQualifications = Nothing
  , cvProjectExperiences = Nothing
  , cvWorkExperiences = Nothing
  , cvLanguages = Nothing
  , cvTechnologies = Nothing
  , cvCertifications = Nothing
  , cvCourses = Nothing
  , cvPresentations = Nothing
  , cvRecommendations = Nothing
  , cvPositions = Nothing
  , cvImage = Nothing
  }

-- ** CvList
-- | CvList
data CvList = CvList
  { cvListTotal :: !(Double) -- ^ /Required/ "total"
  , cvListCvs :: !([CvListEntry]) -- ^ /Required/ "cvs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CvList
instance A.FromJSON CvList where
  parseJSON = A.withObject "CvList" $ \o ->
    CvList
      <$> (o .:  "total")
      <*> (o .:  "cvs")

-- | ToJSON CvList
instance A.ToJSON CvList where
  toJSON CvList {..} =
   _omitNulls
      [ "total" .= cvListTotal
      , "cvs" .= cvListCvs
      ]


-- | Construct a value of type 'CvList' (by applying it's required fields, if any)
mkCvList
  :: Double -- ^ 'cvListTotal' 
  -> [CvListEntry] -- ^ 'cvListCvs' 
  -> CvList
mkCvList cvListTotal cvListCvs =
  CvList
  { cvListTotal
  , cvListCvs
  }

-- ** CvListEntry
-- | CvListEntry
data CvListEntry = CvListEntry
  { cvListEntryPreviewUrl :: !(Text) -- ^ /Required/ "preview_url"
  , cvListEntryCv :: !(CvSummary) -- ^ /Required/ "cv"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CvListEntry
instance A.FromJSON CvListEntry where
  parseJSON = A.withObject "CvListEntry" $ \o ->
    CvListEntry
      <$> (o .:  "preview_url")
      <*> (o .:  "cv")

-- | ToJSON CvListEntry
instance A.ToJSON CvListEntry where
  toJSON CvListEntry {..} =
   _omitNulls
      [ "preview_url" .= cvListEntryPreviewUrl
      , "cv" .= cvListEntryCv
      ]


-- | Construct a value of type 'CvListEntry' (by applying it's required fields, if any)
mkCvListEntry
  :: Text -- ^ 'cvListEntryPreviewUrl' 
  -> CvSummary -- ^ 'cvListEntryCv' 
  -> CvListEntry
mkCvListEntry cvListEntryPreviewUrl cvListEntryCv =
  CvListEntry
  { cvListEntryPreviewUrl
  , cvListEntryCv
  }

-- ** CvSection
-- | CvSection
data CvSection = CvSection
  { cvSectionKeyQualification :: !(Maybe KeyQualification) -- ^ "key_qualification"
  , cvSectionEducation :: !(Maybe Education) -- ^ "education"
  , cvSectionWorkExperience :: !(Maybe WorkExperience) -- ^ "work_experience"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CvSection
instance A.FromJSON CvSection where
  parseJSON = A.withObject "CvSection" $ \o ->
    CvSection
      <$> (o .:? "key_qualification")
      <*> (o .:? "education")
      <*> (o .:? "work_experience")

-- | ToJSON CvSection
instance A.ToJSON CvSection where
  toJSON CvSection {..} =
   _omitNulls
      [ "key_qualification" .= cvSectionKeyQualification
      , "education" .= cvSectionEducation
      , "work_experience" .= cvSectionWorkExperience
      ]


-- | Construct a value of type 'CvSection' (by applying it's required fields, if any)
mkCvSection
  :: CvSection
mkCvSection =
  CvSection
  { cvSectionKeyQualification = Nothing
  , cvSectionEducation = Nothing
  , cvSectionWorkExperience = Nothing
  }

-- ** CvSectionProperties
-- | CvSectionProperties
data CvSectionProperties = CvSectionProperties
  { cvSectionPropertiesOrder :: !(Maybe Int) -- ^ "order"
  , cvSectionPropertiesStarred :: !(Maybe Bool) -- ^ "starred"
  , cvSectionPropertiesDisabled :: !(Maybe Bool) -- ^ "disabled"
  , cvSectionPropertiesVersion :: !(Maybe Int) -- ^ "version"
  , cvSectionPropertiesExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , cvSectionPropertiesOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , cvSectionPropertiesCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , cvSectionPropertiesUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CvSectionProperties
instance A.FromJSON CvSectionProperties where
  parseJSON = A.withObject "CvSectionProperties" $ \o ->
    CvSectionProperties
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")

-- | ToJSON CvSectionProperties
instance A.ToJSON CvSectionProperties where
  toJSON CvSectionProperties {..} =
   _omitNulls
      [ "order" .= cvSectionPropertiesOrder
      , "starred" .= cvSectionPropertiesStarred
      , "disabled" .= cvSectionPropertiesDisabled
      , "version" .= cvSectionPropertiesVersion
      , "external_unique_id" .= cvSectionPropertiesExternalUniqueId
      , "owner_updated_at" .= cvSectionPropertiesOwnerUpdatedAt
      , "created_at" .= cvSectionPropertiesCreatedAt
      , "updated_at" .= cvSectionPropertiesUpdatedAt
      ]


-- | Construct a value of type 'CvSectionProperties' (by applying it's required fields, if any)
mkCvSectionProperties
  :: CvSectionProperties
mkCvSectionProperties =
  CvSectionProperties
  { cvSectionPropertiesOrder = Nothing
  , cvSectionPropertiesStarred = Nothing
  , cvSectionPropertiesDisabled = Nothing
  , cvSectionPropertiesVersion = Nothing
  , cvSectionPropertiesExternalUniqueId = Nothing
  , cvSectionPropertiesOwnerUpdatedAt = Nothing
  , cvSectionPropertiesCreatedAt = Nothing
  , cvSectionPropertiesUpdatedAt = Nothing
  }

-- ** CvSummary
-- | CvSummary
data CvSummary = CvSummary
  { cvSummaryId :: !(Text) -- ^ /Required/ "id"
  , cvSummaryUserId :: !(Maybe Text) -- ^ "user_id"
  , cvSummaryName :: !(Maybe Text) -- ^ "name"
  , cvSummaryImage :: !(Maybe A.Value) -- ^ "image"
  , cvSummaryTitle :: !(Maybe Text) -- ^ "title"
  , cvSummaryTitles :: !(Maybe A.Value) -- ^ "titles"
  , cvSummaryEmail :: !(Maybe Text) -- ^ "email"
  , cvSummaryCompanyId :: !(Maybe Text) -- ^ "company_id"
  , cvSummaryUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , cvSummaryOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , cvSummaryCountryCode :: !(Maybe Text) -- ^ "country_code"
  , cvSummaryLanguageCode :: !(Maybe Text) -- ^ "language_code"
  , cvSummaryLanguageCodes :: !(Maybe [Text]) -- ^ "language_codes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CvSummary
instance A.FromJSON CvSummary where
  parseJSON = A.withObject "CvSummary" $ \o ->
    CvSummary
      <$> (o .:  "id")
      <*> (o .:? "user_id")
      <*> (o .:? "name")
      <*> (o .:? "image")
      <*> (o .:? "title")
      <*> (o .:? "titles")
      <*> (o .:? "email")
      <*> (o .:? "company_id")
      <*> (o .:? "updated_at")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "country_code")
      <*> (o .:? "language_code")
      <*> (o .:? "language_codes")

-- | ToJSON CvSummary
instance A.ToJSON CvSummary where
  toJSON CvSummary {..} =
   _omitNulls
      [ "id" .= cvSummaryId
      , "user_id" .= cvSummaryUserId
      , "name" .= cvSummaryName
      , "image" .= cvSummaryImage
      , "title" .= cvSummaryTitle
      , "titles" .= cvSummaryTitles
      , "email" .= cvSummaryEmail
      , "company_id" .= cvSummaryCompanyId
      , "updated_at" .= cvSummaryUpdatedAt
      , "owner_updated_at" .= cvSummaryOwnerUpdatedAt
      , "country_code" .= cvSummaryCountryCode
      , "language_code" .= cvSummaryLanguageCode
      , "language_codes" .= cvSummaryLanguageCodes
      ]


-- | Construct a value of type 'CvSummary' (by applying it's required fields, if any)
mkCvSummary
  :: Text -- ^ 'cvSummaryId' 
  -> CvSummary
mkCvSummary cvSummaryId =
  CvSummary
  { cvSummaryId
  , cvSummaryUserId = Nothing
  , cvSummaryName = Nothing
  , cvSummaryImage = Nothing
  , cvSummaryTitle = Nothing
  , cvSummaryTitles = Nothing
  , cvSummaryEmail = Nothing
  , cvSummaryCompanyId = Nothing
  , cvSummaryUpdatedAt = Nothing
  , cvSummaryOwnerUpdatedAt = Nothing
  , cvSummaryCountryCode = Nothing
  , cvSummaryLanguageCode = Nothing
  , cvSummaryLanguageCodes = Nothing
  }

-- ** Education
-- | Education
data Education = Education
  { educationOrder :: !(Maybe Int) -- ^ "order"
  , educationStarred :: !(Maybe Bool) -- ^ "starred"
  , educationDisabled :: !(Maybe Bool) -- ^ "disabled"
  , educationVersion :: !(Maybe Int) -- ^ "version"
  , educationExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , educationOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , educationCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , educationUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , educationDegree :: !(Maybe A.Value) -- ^ "degree"
  , educationDescription :: !(Maybe A.Value) -- ^ "description"
  , educationYearFrom :: !(Maybe Text) -- ^ "year_from"
  , educationMonthFrom :: !(Maybe Text) -- ^ "month_from"
  , educationYearTo :: !(Maybe Text) -- ^ "year_to"
  , educationMonthTo :: !(Maybe Text) -- ^ "month_to"
  , educationSchool :: !(Maybe A.Value) -- ^ "school"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Education
instance A.FromJSON Education where
  parseJSON = A.withObject "Education" $ \o ->
    Education
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "degree")
      <*> (o .:? "description")
      <*> (o .:? "year_from")
      <*> (o .:? "month_from")
      <*> (o .:? "year_to")
      <*> (o .:? "month_to")
      <*> (o .:? "school")

-- | ToJSON Education
instance A.ToJSON Education where
  toJSON Education {..} =
   _omitNulls
      [ "order" .= educationOrder
      , "starred" .= educationStarred
      , "disabled" .= educationDisabled
      , "version" .= educationVersion
      , "external_unique_id" .= educationExternalUniqueId
      , "owner_updated_at" .= educationOwnerUpdatedAt
      , "created_at" .= educationCreatedAt
      , "updated_at" .= educationUpdatedAt
      , "degree" .= educationDegree
      , "description" .= educationDescription
      , "year_from" .= educationYearFrom
      , "month_from" .= educationMonthFrom
      , "year_to" .= educationYearTo
      , "month_to" .= educationMonthTo
      , "school" .= educationSchool
      ]


-- | Construct a value of type 'Education' (by applying it's required fields, if any)
mkEducation
  :: Education
mkEducation =
  Education
  { educationOrder = Nothing
  , educationStarred = Nothing
  , educationDisabled = Nothing
  , educationVersion = Nothing
  , educationExternalUniqueId = Nothing
  , educationOwnerUpdatedAt = Nothing
  , educationCreatedAt = Nothing
  , educationUpdatedAt = Nothing
  , educationDegree = Nothing
  , educationDescription = Nothing
  , educationYearFrom = Nothing
  , educationMonthFrom = Nothing
  , educationYearTo = Nothing
  , educationMonthTo = Nothing
  , educationSchool = Nothing
  }

-- ** ImageUrl
-- | ImageUrl
data ImageUrl = ImageUrl
  { imageUrlUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageUrl
instance A.FromJSON ImageUrl where
  parseJSON = A.withObject "ImageUrl" $ \o ->
    ImageUrl
      <$> (o .:? "url")

-- | ToJSON ImageUrl
instance A.ToJSON ImageUrl where
  toJSON ImageUrl {..} =
   _omitNulls
      [ "url" .= imageUrlUrl
      ]


-- | Construct a value of type 'ImageUrl' (by applying it's required fields, if any)
mkImageUrl
  :: ImageUrl
mkImageUrl =
  ImageUrl
  { imageUrlUrl = Nothing
  }

-- ** KeyQualification
-- | KeyQualification
data KeyQualification = KeyQualification
  { keyQualificationOrder :: !(Maybe Int) -- ^ "order"
  , keyQualificationStarred :: !(Maybe Bool) -- ^ "starred"
  , keyQualificationDisabled :: !(Maybe Bool) -- ^ "disabled"
  , keyQualificationVersion :: !(Maybe Int) -- ^ "version"
  , keyQualificationExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , keyQualificationOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , keyQualificationCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , keyQualificationUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , keyQualificationRecentlyAdded :: !(Maybe Bool) -- ^ "recently_added"
  , keyQualificationLabel :: !(Maybe A.Value) -- ^ "label"
  , keyQualificationLongDescription :: !(Maybe A.Value) -- ^ "long_description"
  , keyQualificationTagLine :: !(Maybe A.Value) -- ^ "tag_line"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON KeyQualification
instance A.FromJSON KeyQualification where
  parseJSON = A.withObject "KeyQualification" $ \o ->
    KeyQualification
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "recently_added")
      <*> (o .:? "label")
      <*> (o .:? "long_description")
      <*> (o .:? "tag_line")

-- | ToJSON KeyQualification
instance A.ToJSON KeyQualification where
  toJSON KeyQualification {..} =
   _omitNulls
      [ "order" .= keyQualificationOrder
      , "starred" .= keyQualificationStarred
      , "disabled" .= keyQualificationDisabled
      , "version" .= keyQualificationVersion
      , "external_unique_id" .= keyQualificationExternalUniqueId
      , "owner_updated_at" .= keyQualificationOwnerUpdatedAt
      , "created_at" .= keyQualificationCreatedAt
      , "updated_at" .= keyQualificationUpdatedAt
      , "recently_added" .= keyQualificationRecentlyAdded
      , "label" .= keyQualificationLabel
      , "long_description" .= keyQualificationLongDescription
      , "tag_line" .= keyQualificationTagLine
      ]


-- | Construct a value of type 'KeyQualification' (by applying it's required fields, if any)
mkKeyQualification
  :: KeyQualification
mkKeyQualification =
  KeyQualification
  { keyQualificationOrder = Nothing
  , keyQualificationStarred = Nothing
  , keyQualificationDisabled = Nothing
  , keyQualificationVersion = Nothing
  , keyQualificationExternalUniqueId = Nothing
  , keyQualificationOwnerUpdatedAt = Nothing
  , keyQualificationCreatedAt = Nothing
  , keyQualificationUpdatedAt = Nothing
  , keyQualificationRecentlyAdded = Nothing
  , keyQualificationLabel = Nothing
  , keyQualificationLongDescription = Nothing
  , keyQualificationTagLine = Nothing
  }

-- ** Language
-- | Language
data Language = Language
  { languageOrder :: !(Maybe Int) -- ^ "order"
  , languageStarred :: !(Maybe Bool) -- ^ "starred"
  , languageDisabled :: !(Maybe Bool) -- ^ "disabled"
  , languageVersion :: !(Maybe Int) -- ^ "version"
  , languageExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , languageOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , languageCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , languageUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , languageLevel :: !(Maybe A.Value) -- ^ "level"
  , languageName :: !(Maybe A.Value) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Language
instance A.FromJSON Language where
  parseJSON = A.withObject "Language" $ \o ->
    Language
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "level")
      <*> (o .:? "name")

-- | ToJSON Language
instance A.ToJSON Language where
  toJSON Language {..} =
   _omitNulls
      [ "order" .= languageOrder
      , "starred" .= languageStarred
      , "disabled" .= languageDisabled
      , "version" .= languageVersion
      , "external_unique_id" .= languageExternalUniqueId
      , "owner_updated_at" .= languageOwnerUpdatedAt
      , "created_at" .= languageCreatedAt
      , "updated_at" .= languageUpdatedAt
      , "level" .= languageLevel
      , "name" .= languageName
      ]


-- | Construct a value of type 'Language' (by applying it's required fields, if any)
mkLanguage
  :: Language
mkLanguage =
  Language
  { languageOrder = Nothing
  , languageStarred = Nothing
  , languageDisabled = Nothing
  , languageVersion = Nothing
  , languageExternalUniqueId = Nothing
  , languageOwnerUpdatedAt = Nothing
  , languageCreatedAt = Nothing
  , languageUpdatedAt = Nothing
  , languageLevel = Nothing
  , languageName = Nothing
  }

-- ** Office
-- | Office
data Office = Office
  { officeId :: !(Text) -- ^ /Required/ "_id"
  , officeName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Office
instance A.FromJSON Office where
  parseJSON = A.withObject "Office" $ \o ->
    Office
      <$> (o .:  "_id")
      <*> (o .:  "name")

-- | ToJSON Office
instance A.ToJSON Office where
  toJSON Office {..} =
   _omitNulls
      [ "_id" .= officeId
      , "name" .= officeName
      ]


-- | Construct a value of type 'Office' (by applying it's required fields, if any)
mkOffice
  :: Text -- ^ 'officeId' 
  -> Text -- ^ 'officeName' 
  -> Office
mkOffice officeId officeName =
  Office
  { officeId
  , officeName
  }

-- ** Position
-- | Position
data Position = Position
  { positionOrder :: !(Maybe Int) -- ^ "order"
  , positionStarred :: !(Maybe Bool) -- ^ "starred"
  , positionDisabled :: !(Maybe Bool) -- ^ "disabled"
  , positionVersion :: !(Maybe Int) -- ^ "version"
  , positionExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , positionOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , positionCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , positionUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , positionName :: !(Maybe A.Value) -- ^ "name"
  , positionDescription :: !(Maybe A.Value) -- ^ "description"
  , positionYearFrom :: !(Maybe Text) -- ^ "year_from"
  , positionYearTo :: !(Maybe Text) -- ^ "year_to"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Position
instance A.FromJSON Position where
  parseJSON = A.withObject "Position" $ \o ->
    Position
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "year_from")
      <*> (o .:? "year_to")

-- | ToJSON Position
instance A.ToJSON Position where
  toJSON Position {..} =
   _omitNulls
      [ "order" .= positionOrder
      , "starred" .= positionStarred
      , "disabled" .= positionDisabled
      , "version" .= positionVersion
      , "external_unique_id" .= positionExternalUniqueId
      , "owner_updated_at" .= positionOwnerUpdatedAt
      , "created_at" .= positionCreatedAt
      , "updated_at" .= positionUpdatedAt
      , "name" .= positionName
      , "description" .= positionDescription
      , "year_from" .= positionYearFrom
      , "year_to" .= positionYearTo
      ]


-- | Construct a value of type 'Position' (by applying it's required fields, if any)
mkPosition
  :: Position
mkPosition =
  Position
  { positionOrder = Nothing
  , positionStarred = Nothing
  , positionDisabled = Nothing
  , positionVersion = Nothing
  , positionExternalUniqueId = Nothing
  , positionOwnerUpdatedAt = Nothing
  , positionCreatedAt = Nothing
  , positionUpdatedAt = Nothing
  , positionName = Nothing
  , positionDescription = Nothing
  , positionYearFrom = Nothing
  , positionYearTo = Nothing
  }

-- ** Presentation
-- | Presentation
data Presentation = Presentation
  { presentationOrder :: !(Maybe Int) -- ^ "order"
  , presentationStarred :: !(Maybe Bool) -- ^ "starred"
  , presentationDisabled :: !(Maybe Bool) -- ^ "disabled"
  , presentationVersion :: !(Maybe Int) -- ^ "version"
  , presentationExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , presentationOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , presentationCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , presentationUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , presentationDescription :: !(Maybe A.Value) -- ^ "description"
  , presentationLongDescription :: !(Maybe A.Value) -- ^ "long_description"
  , presentationYear :: !(Maybe Text) -- ^ "year"
  , presentationMonth :: !(Maybe Text) -- ^ "month"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Presentation
instance A.FromJSON Presentation where
  parseJSON = A.withObject "Presentation" $ \o ->
    Presentation
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "description")
      <*> (o .:? "long_description")
      <*> (o .:? "year")
      <*> (o .:? "month")

-- | ToJSON Presentation
instance A.ToJSON Presentation where
  toJSON Presentation {..} =
   _omitNulls
      [ "order" .= presentationOrder
      , "starred" .= presentationStarred
      , "disabled" .= presentationDisabled
      , "version" .= presentationVersion
      , "external_unique_id" .= presentationExternalUniqueId
      , "owner_updated_at" .= presentationOwnerUpdatedAt
      , "created_at" .= presentationCreatedAt
      , "updated_at" .= presentationUpdatedAt
      , "description" .= presentationDescription
      , "long_description" .= presentationLongDescription
      , "year" .= presentationYear
      , "month" .= presentationMonth
      ]


-- | Construct a value of type 'Presentation' (by applying it's required fields, if any)
mkPresentation
  :: Presentation
mkPresentation =
  Presentation
  { presentationOrder = Nothing
  , presentationStarred = Nothing
  , presentationDisabled = Nothing
  , presentationVersion = Nothing
  , presentationExternalUniqueId = Nothing
  , presentationOwnerUpdatedAt = Nothing
  , presentationCreatedAt = Nothing
  , presentationUpdatedAt = Nothing
  , presentationDescription = Nothing
  , presentationLongDescription = Nothing
  , presentationYear = Nothing
  , presentationMonth = Nothing
  }

-- ** ProjectExperience
-- | ProjectExperience
data ProjectExperience = ProjectExperience
  { projectExperienceOrder :: !(Maybe Int) -- ^ "order"
  , projectExperienceStarred :: !(Maybe Bool) -- ^ "starred"
  , projectExperienceDisabled :: !(Maybe Bool) -- ^ "disabled"
  , projectExperienceVersion :: !(Maybe Int) -- ^ "version"
  , projectExperienceExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , projectExperienceOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , projectExperienceCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , projectExperienceUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , projectExperienceAreaAmt :: !(Maybe Text) -- ^ "area_amt"
  , projectExperienceAreaUnit :: !(Maybe Text) -- ^ "area_unit"
  , projectExperienceCustomer :: !(Maybe A.Value) -- ^ "customer"
  , projectExperienceCustomerAnonymized :: !(Maybe A.Value) -- ^ "customer_anonymized"
  , projectExperienceCustomerDescription :: !(Maybe A.Value) -- ^ "customer_description"
  , projectExperienceDescription :: !(Maybe A.Value) -- ^ "description"
  , projectExperienceLongDescription :: !(Maybe A.Value) -- ^ "long_description"
  , projectExperienceIndustry :: !(Maybe A.Value) -- ^ "industry"
  , projectExperienceYearFrom :: !(Maybe Text) -- ^ "year_from"
  , projectExperienceMonthFrom :: !(Maybe Text) -- ^ "month_from"
  , projectExperienceYearTo :: !(Maybe Text) -- ^ "year_to"
  , projectExperienceMonthTo :: !(Maybe Text) -- ^ "month_to"
  , projectExperienceRoles :: !(Maybe [ProjectRole]) -- ^ "roles"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectExperience
instance A.FromJSON ProjectExperience where
  parseJSON = A.withObject "ProjectExperience" $ \o ->
    ProjectExperience
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "area_amt")
      <*> (o .:? "area_unit")
      <*> (o .:? "customer")
      <*> (o .:? "customer_anonymized")
      <*> (o .:? "customer_description")
      <*> (o .:? "description")
      <*> (o .:? "long_description")
      <*> (o .:? "industry")
      <*> (o .:? "year_from")
      <*> (o .:? "month_from")
      <*> (o .:? "year_to")
      <*> (o .:? "month_to")
      <*> (o .:? "roles")

-- | ToJSON ProjectExperience
instance A.ToJSON ProjectExperience where
  toJSON ProjectExperience {..} =
   _omitNulls
      [ "order" .= projectExperienceOrder
      , "starred" .= projectExperienceStarred
      , "disabled" .= projectExperienceDisabled
      , "version" .= projectExperienceVersion
      , "external_unique_id" .= projectExperienceExternalUniqueId
      , "owner_updated_at" .= projectExperienceOwnerUpdatedAt
      , "created_at" .= projectExperienceCreatedAt
      , "updated_at" .= projectExperienceUpdatedAt
      , "area_amt" .= projectExperienceAreaAmt
      , "area_unit" .= projectExperienceAreaUnit
      , "customer" .= projectExperienceCustomer
      , "customer_anonymized" .= projectExperienceCustomerAnonymized
      , "customer_description" .= projectExperienceCustomerDescription
      , "description" .= projectExperienceDescription
      , "long_description" .= projectExperienceLongDescription
      , "industry" .= projectExperienceIndustry
      , "year_from" .= projectExperienceYearFrom
      , "month_from" .= projectExperienceMonthFrom
      , "year_to" .= projectExperienceYearTo
      , "month_to" .= projectExperienceMonthTo
      , "roles" .= projectExperienceRoles
      ]


-- | Construct a value of type 'ProjectExperience' (by applying it's required fields, if any)
mkProjectExperience
  :: ProjectExperience
mkProjectExperience =
  ProjectExperience
  { projectExperienceOrder = Nothing
  , projectExperienceStarred = Nothing
  , projectExperienceDisabled = Nothing
  , projectExperienceVersion = Nothing
  , projectExperienceExternalUniqueId = Nothing
  , projectExperienceOwnerUpdatedAt = Nothing
  , projectExperienceCreatedAt = Nothing
  , projectExperienceUpdatedAt = Nothing
  , projectExperienceAreaAmt = Nothing
  , projectExperienceAreaUnit = Nothing
  , projectExperienceCustomer = Nothing
  , projectExperienceCustomerAnonymized = Nothing
  , projectExperienceCustomerDescription = Nothing
  , projectExperienceDescription = Nothing
  , projectExperienceLongDescription = Nothing
  , projectExperienceIndustry = Nothing
  , projectExperienceYearFrom = Nothing
  , projectExperienceMonthFrom = Nothing
  , projectExperienceYearTo = Nothing
  , projectExperienceMonthTo = Nothing
  , projectExperienceRoles = Nothing
  }

-- ** ProjectRole
-- | ProjectRole
data ProjectRole = ProjectRole
  { projectRoleOrder :: !(Maybe Int) -- ^ "order"
  , projectRoleStarred :: !(Maybe Bool) -- ^ "starred"
  , projectRoleDisabled :: !(Maybe Bool) -- ^ "disabled"
  , projectRoleVersion :: !(Maybe Int) -- ^ "version"
  , projectRoleExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , projectRoleOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , projectRoleCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , projectRoleUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , projectRoleCvRoleId :: !(Maybe Text) -- ^ "cv_role_id"
  , projectRoleDivergedFromMaster :: !(Maybe Bool) -- ^ "diverged_from_master"
  , projectRoleName :: !(Maybe A.Value) -- ^ "name"
  , projectRoleSummary :: !(Maybe A.Value) -- ^ "summary"
  , projectRoleLongDescription :: !(Maybe A.Value) -- ^ "long_description"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProjectRole
instance A.FromJSON ProjectRole where
  parseJSON = A.withObject "ProjectRole" $ \o ->
    ProjectRole
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "cv_role_id")
      <*> (o .:? "diverged_from_master")
      <*> (o .:? "name")
      <*> (o .:? "summary")
      <*> (o .:? "long_description")

-- | ToJSON ProjectRole
instance A.ToJSON ProjectRole where
  toJSON ProjectRole {..} =
   _omitNulls
      [ "order" .= projectRoleOrder
      , "starred" .= projectRoleStarred
      , "disabled" .= projectRoleDisabled
      , "version" .= projectRoleVersion
      , "external_unique_id" .= projectRoleExternalUniqueId
      , "owner_updated_at" .= projectRoleOwnerUpdatedAt
      , "created_at" .= projectRoleCreatedAt
      , "updated_at" .= projectRoleUpdatedAt
      , "cv_role_id" .= projectRoleCvRoleId
      , "diverged_from_master" .= projectRoleDivergedFromMaster
      , "name" .= projectRoleName
      , "summary" .= projectRoleSummary
      , "long_description" .= projectRoleLongDescription
      ]


-- | Construct a value of type 'ProjectRole' (by applying it's required fields, if any)
mkProjectRole
  :: ProjectRole
mkProjectRole =
  ProjectRole
  { projectRoleOrder = Nothing
  , projectRoleStarred = Nothing
  , projectRoleDisabled = Nothing
  , projectRoleVersion = Nothing
  , projectRoleExternalUniqueId = Nothing
  , projectRoleOwnerUpdatedAt = Nothing
  , projectRoleCreatedAt = Nothing
  , projectRoleUpdatedAt = Nothing
  , projectRoleCvRoleId = Nothing
  , projectRoleDivergedFromMaster = Nothing
  , projectRoleName = Nothing
  , projectRoleSummary = Nothing
  , projectRoleLongDescription = Nothing
  }

-- ** Recommendation
-- | Recommendation
data Recommendation = Recommendation
  { recommendationOrder :: !(Maybe Int) -- ^ "order"
  , recommendationStarred :: !(Maybe Bool) -- ^ "starred"
  , recommendationDisabled :: !(Maybe Bool) -- ^ "disabled"
  , recommendationVersion :: !(Maybe Int) -- ^ "version"
  , recommendationExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , recommendationOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , recommendationCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , recommendationUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , recommendationDescription :: !(Maybe A.Value) -- ^ "description"
  , recommendationRecommender :: !(Maybe A.Value) -- ^ "recommender"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Recommendation
instance A.FromJSON Recommendation where
  parseJSON = A.withObject "Recommendation" $ \o ->
    Recommendation
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "description")
      <*> (o .:? "recommender")

-- | ToJSON Recommendation
instance A.ToJSON Recommendation where
  toJSON Recommendation {..} =
   _omitNulls
      [ "order" .= recommendationOrder
      , "starred" .= recommendationStarred
      , "disabled" .= recommendationDisabled
      , "version" .= recommendationVersion
      , "external_unique_id" .= recommendationExternalUniqueId
      , "owner_updated_at" .= recommendationOwnerUpdatedAt
      , "created_at" .= recommendationCreatedAt
      , "updated_at" .= recommendationUpdatedAt
      , "description" .= recommendationDescription
      , "recommender" .= recommendationRecommender
      ]


-- | Construct a value of type 'Recommendation' (by applying it's required fields, if any)
mkRecommendation
  :: Recommendation
mkRecommendation =
  Recommendation
  { recommendationOrder = Nothing
  , recommendationStarred = Nothing
  , recommendationDisabled = Nothing
  , recommendationVersion = Nothing
  , recommendationExternalUniqueId = Nothing
  , recommendationOwnerUpdatedAt = Nothing
  , recommendationCreatedAt = Nothing
  , recommendationUpdatedAt = Nothing
  , recommendationDescription = Nothing
  , recommendationRecommender = Nothing
  }

-- ** SearchByNameReq
-- | SearchByNameReq
data SearchByNameReq = SearchByNameReq
  { searchByNameReqOfficeIds :: !(Maybe [Text]) -- ^ "office_ids"
  , searchByNameReqOffset :: !(Double) -- ^ /Required/ "offset"
  , searchByNameReqSize :: !(Double) -- ^ /Required/ "size"
  , searchByNameReqMust :: !(A.Value) -- ^ /Required/ "must"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchByNameReq
instance A.FromJSON SearchByNameReq where
  parseJSON = A.withObject "SearchByNameReq" $ \o ->
    SearchByNameReq
      <$> (o .:? "office_ids")
      <*> (o .:  "offset")
      <*> (o .:  "size")
      <*> (o .:  "must")

-- | ToJSON SearchByNameReq
instance A.ToJSON SearchByNameReq where
  toJSON SearchByNameReq {..} =
   _omitNulls
      [ "office_ids" .= searchByNameReqOfficeIds
      , "offset" .= searchByNameReqOffset
      , "size" .= searchByNameReqSize
      , "must" .= searchByNameReqMust
      ]


-- | Construct a value of type 'SearchByNameReq' (by applying it's required fields, if any)
mkSearchByNameReq
  :: Double -- ^ 'searchByNameReqOffset' 
  -> Double -- ^ 'searchByNameReqSize' 
  -> A.Value -- ^ 'searchByNameReqMust' 
  -> SearchByNameReq
mkSearchByNameReq searchByNameReqOffset searchByNameReqSize searchByNameReqMust =
  SearchByNameReq
  { searchByNameReqOfficeIds = Nothing
  , searchByNameReqOffset
  , searchByNameReqSize
  , searchByNameReqMust
  }

-- ** Technology
-- | Technology
data Technology = Technology
  { technologyOrder :: !(Maybe Int) -- ^ "order"
  , technologyStarred :: !(Maybe Bool) -- ^ "starred"
  , technologyDisabled :: !(Maybe Bool) -- ^ "disabled"
  , technologyVersion :: !(Maybe Int) -- ^ "version"
  , technologyExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , technologyOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , technologyCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , technologyUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , technologyUncategorized :: !(Maybe Bool) -- ^ "uncategorized"
  , technologyCategory :: !(Maybe A.Value) -- ^ "category"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Technology
instance A.FromJSON Technology where
  parseJSON = A.withObject "Technology" $ \o ->
    Technology
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "uncategorized")
      <*> (o .:? "category")

-- | ToJSON Technology
instance A.ToJSON Technology where
  toJSON Technology {..} =
   _omitNulls
      [ "order" .= technologyOrder
      , "starred" .= technologyStarred
      , "disabled" .= technologyDisabled
      , "version" .= technologyVersion
      , "external_unique_id" .= technologyExternalUniqueId
      , "owner_updated_at" .= technologyOwnerUpdatedAt
      , "created_at" .= technologyCreatedAt
      , "updated_at" .= technologyUpdatedAt
      , "uncategorized" .= technologyUncategorized
      , "category" .= technologyCategory
      ]


-- | Construct a value of type 'Technology' (by applying it's required fields, if any)
mkTechnology
  :: Technology
mkTechnology =
  Technology
  { technologyOrder = Nothing
  , technologyStarred = Nothing
  , technologyDisabled = Nothing
  , technologyVersion = Nothing
  , technologyExternalUniqueId = Nothing
  , technologyOwnerUpdatedAt = Nothing
  , technologyCreatedAt = Nothing
  , technologyUpdatedAt = Nothing
  , technologyUncategorized = Nothing
  , technologyCategory = Nothing
  }

-- ** User
-- | User
data User = User
  { userUserId :: !(Text) -- ^ /Required/ "user_id"
  , userId :: !(Text) -- ^ /Required/ "id"
  , userEmail :: !(Maybe Text) -- ^ "email"
  , userExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , userUpn :: !(Maybe Text) -- ^ "upn"
  , userName :: !(Maybe Text) -- ^ "name"
  , userTelephone :: !(Maybe Text) -- ^ "telephone"
  , userDefaultCvId :: !(Maybe Text) -- ^ "default_cv_id"
  , userDeactivated :: !(Maybe Bool) -- ^ "deactivated"
  , userDeactivatedAt :: !(Maybe Bool) -- ^ "deactivated_at"
  , userCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , userUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , userRole :: !(Maybe Text) -- ^ "role"
  , userExtraRoles :: !(Maybe [Text]) -- ^ "extra_roles"
  , userOfficeId :: !(Maybe Text) -- ^ "office_id"
  , userOfficeName :: !(Maybe Text) -- ^ "office_name"
  , userCountryId :: !(Maybe Text) -- ^ "country_id"
  , userCountryCode :: !(Maybe Text) -- ^ "country_code"
  , userLanguageCode :: !(Maybe Text) -- ^ "language_code"
  , userImage :: !(Maybe UserImage) -- ^ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON User
instance A.FromJSON User where
  parseJSON = A.withObject "User" $ \o ->
    User
      <$> (o .:  "user_id")
      <*> (o .:  "id")
      <*> (o .:? "email")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "upn")
      <*> (o .:? "name")
      <*> (o .:? "telephone")
      <*> (o .:? "default_cv_id")
      <*> (o .:? "deactivated")
      <*> (o .:? "deactivated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "role")
      <*> (o .:? "extra_roles")
      <*> (o .:? "office_id")
      <*> (o .:? "office_name")
      <*> (o .:? "country_id")
      <*> (o .:? "country_code")
      <*> (o .:? "language_code")
      <*> (o .:? "image")

-- | ToJSON User
instance A.ToJSON User where
  toJSON User {..} =
   _omitNulls
      [ "user_id" .= userUserId
      , "id" .= userId
      , "email" .= userEmail
      , "external_unique_id" .= userExternalUniqueId
      , "upn" .= userUpn
      , "name" .= userName
      , "telephone" .= userTelephone
      , "default_cv_id" .= userDefaultCvId
      , "deactivated" .= userDeactivated
      , "deactivated_at" .= userDeactivatedAt
      , "created_at" .= userCreatedAt
      , "updated_at" .= userUpdatedAt
      , "role" .= userRole
      , "extra_roles" .= userExtraRoles
      , "office_id" .= userOfficeId
      , "office_name" .= userOfficeName
      , "country_id" .= userCountryId
      , "country_code" .= userCountryCode
      , "language_code" .= userLanguageCode
      , "image" .= userImage
      ]


-- | Construct a value of type 'User' (by applying it's required fields, if any)
mkUser
  :: Text -- ^ 'userUserId' 
  -> Text -- ^ 'userId' 
  -> User
mkUser userUserId userId =
  User
  { userUserId
  , userId
  , userEmail = Nothing
  , userExternalUniqueId = Nothing
  , userUpn = Nothing
  , userName = Nothing
  , userTelephone = Nothing
  , userDefaultCvId = Nothing
  , userDeactivated = Nothing
  , userDeactivatedAt = Nothing
  , userCreatedAt = Nothing
  , userUpdatedAt = Nothing
  , userRole = Nothing
  , userExtraRoles = Nothing
  , userOfficeId = Nothing
  , userOfficeName = Nothing
  , userCountryId = Nothing
  , userCountryCode = Nothing
  , userLanguageCode = Nothing
  , userImage = Nothing
  }

-- ** UserImage
-- | UserImage
data UserImage = UserImage
  { userImageUrl :: !(Maybe Text) -- ^ "url"
  , userImageThumb :: !(Maybe ImageUrl) -- ^ "thumb"
  , userImageFitThumb :: !(Maybe ImageUrl) -- ^ "fit_thumb"
  , userImageLarge :: !(Maybe ImageUrl) -- ^ "large"
  , userImageSmallThumb :: !(Maybe ImageUrl) -- ^ "small_thumb"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserImage
instance A.FromJSON UserImage where
  parseJSON = A.withObject "UserImage" $ \o ->
    UserImage
      <$> (o .:? "url")
      <*> (o .:? "thumb")
      <*> (o .:? "fit_thumb")
      <*> (o .:? "large")
      <*> (o .:? "small_thumb")

-- | ToJSON UserImage
instance A.ToJSON UserImage where
  toJSON UserImage {..} =
   _omitNulls
      [ "url" .= userImageUrl
      , "thumb" .= userImageThumb
      , "fit_thumb" .= userImageFitThumb
      , "large" .= userImageLarge
      , "small_thumb" .= userImageSmallThumb
      ]


-- | Construct a value of type 'UserImage' (by applying it's required fields, if any)
mkUserImage
  :: UserImage
mkUserImage =
  UserImage
  { userImageUrl = Nothing
  , userImageThumb = Nothing
  , userImageFitThumb = Nothing
  , userImageLarge = Nothing
  , userImageSmallThumb = Nothing
  }

-- ** WorkExperience
-- | WorkExperience
data WorkExperience = WorkExperience
  { workExperienceOrder :: !(Maybe Int) -- ^ "order"
  , workExperienceStarred :: !(Maybe Bool) -- ^ "starred"
  , workExperienceDisabled :: !(Maybe Bool) -- ^ "disabled"
  , workExperienceVersion :: !(Maybe Int) -- ^ "version"
  , workExperienceExternalUniqueId :: !(Maybe Text) -- ^ "external_unique_id"
  , workExperienceOwnerUpdatedAt :: !(Maybe Text) -- ^ "owner_updated_at"
  , workExperienceCreatedAt :: !(Maybe Text) -- ^ "created_at"
  , workExperienceUpdatedAt :: !(Maybe Text) -- ^ "updated_at"
  , workExperienceEmployer :: !(Maybe A.Value) -- ^ "employer"
  , workExperienceDescription :: !(Maybe A.Value) -- ^ "description"
  , workExperienceLongDescription :: !(Maybe A.Value) -- ^ "long_description"
  , workExperienceYearFrom :: !(Maybe Text) -- ^ "year_from"
  , workExperienceMonthFrom :: !(Maybe Text) -- ^ "month_from"
  , workExperienceYearTo :: !(Maybe Text) -- ^ "year_to"
  , workExperienceMonthTo :: !(Maybe Text) -- ^ "month_to"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WorkExperience
instance A.FromJSON WorkExperience where
  parseJSON = A.withObject "WorkExperience" $ \o ->
    WorkExperience
      <$> (o .:? "order")
      <*> (o .:? "starred")
      <*> (o .:? "disabled")
      <*> (o .:? "version")
      <*> (o .:? "external_unique_id")
      <*> (o .:? "owner_updated_at")
      <*> (o .:? "created_at")
      <*> (o .:? "updated_at")
      <*> (o .:? "employer")
      <*> (o .:? "description")
      <*> (o .:? "long_description")
      <*> (o .:? "year_from")
      <*> (o .:? "month_from")
      <*> (o .:? "year_to")
      <*> (o .:? "month_to")

-- | ToJSON WorkExperience
instance A.ToJSON WorkExperience where
  toJSON WorkExperience {..} =
   _omitNulls
      [ "order" .= workExperienceOrder
      , "starred" .= workExperienceStarred
      , "disabled" .= workExperienceDisabled
      , "version" .= workExperienceVersion
      , "external_unique_id" .= workExperienceExternalUniqueId
      , "owner_updated_at" .= workExperienceOwnerUpdatedAt
      , "created_at" .= workExperienceCreatedAt
      , "updated_at" .= workExperienceUpdatedAt
      , "employer" .= workExperienceEmployer
      , "description" .= workExperienceDescription
      , "long_description" .= workExperienceLongDescription
      , "year_from" .= workExperienceYearFrom
      , "month_from" .= workExperienceMonthFrom
      , "year_to" .= workExperienceYearTo
      , "month_to" .= workExperienceMonthTo
      ]


-- | Construct a value of type 'WorkExperience' (by applying it's required fields, if any)
mkWorkExperience
  :: WorkExperience
mkWorkExperience =
  WorkExperience
  { workExperienceOrder = Nothing
  , workExperienceStarred = Nothing
  , workExperienceDisabled = Nothing
  , workExperienceVersion = Nothing
  , workExperienceExternalUniqueId = Nothing
  , workExperienceOwnerUpdatedAt = Nothing
  , workExperienceCreatedAt = Nothing
  , workExperienceUpdatedAt = Nothing
  , workExperienceEmployer = Nothing
  , workExperienceDescription = Nothing
  , workExperienceLongDescription = Nothing
  , workExperienceYearFrom = Nothing
  , workExperienceMonthFrom = Nothing
  , workExperienceYearTo = Nothing
  , workExperienceMonthTo = Nothing
  }




-- * Auth Methods

-- ** AuthBasicBasicAuth
data AuthBasicBasicAuth =
  AuthBasicBasicAuth B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicBasicAuth where
  applyAuthMethod _ a@(AuthBasicBasicAuth user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])


